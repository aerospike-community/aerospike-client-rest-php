<?php
/**
 * BatchReadOperationsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Aerospike REST Client
 *
 * REST Interface for Aerospike Database.
 *
 * OpenAPI spec version: 1.6.2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.23
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * BatchReadOperationsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BatchReadOperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation performBatchGet
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \Swagger\Client\Model\BatchReadRequest[] $body batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#x27;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional, default to true)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional, default to false)
     * @param  string $keytype The Type of the userKey. (optional, default to STRING)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional, default to 1)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional, default to null)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional, default to ONE)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional, default to SESSION)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional, default to SEQUENCE)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional, default to false)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional, default to false)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchRead[]
     */
    public function performBatchGet($body, $authorization = null, $allow_inline = 'true', $compress = 'false', $keytype = 'STRING', $max_concurrent_threads = '1', $max_retries = null, $predexp = 'null', $read_mode_ap = 'ONE', $read_mode_sc = 'SESSION', $record_bins = null, $replica = 'SEQUENCE', $send_key = 'false', $send_set_name = 'false', $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        list($response) = $this->performBatchGetWithHttpInfo($body, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout);
        return $response;
    }

    /**
     * Operation performBatchGetWithHttpInfo
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \Swagger\Client\Model\BatchReadRequest[] $body batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#x27;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional, default to true)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional, default to false)
     * @param  string $keytype The Type of the userKey. (optional, default to STRING)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional, default to 1)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional, default to null)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional, default to ONE)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional, default to SESSION)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional, default to SEQUENCE)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional, default to false)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional, default to false)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchRead[], HTTP status code, HTTP response headers (array of strings)
     */
    public function performBatchGetWithHttpInfo($body, $authorization = null, $allow_inline = 'true', $compress = 'false', $keytype = 'STRING', $max_concurrent_threads = '1', $max_retries = null, $predexp = 'null', $read_mode_ap = 'ONE', $read_mode_sc = 'SESSION', $record_bins = null, $replica = 'SEQUENCE', $send_key = 'false', $send_set_name = 'false', $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $returnType = '\Swagger\Client\Model\BatchRead[]';
        $request = $this->performBatchGetRequest($body, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchRead[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation performBatchGetAsync
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \Swagger\Client\Model\BatchReadRequest[] $body batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#x27;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional, default to true)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional, default to false)
     * @param  string $keytype The Type of the userKey. (optional, default to STRING)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional, default to 1)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional, default to null)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional, default to ONE)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional, default to SESSION)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional, default to SEQUENCE)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional, default to false)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional, default to false)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performBatchGetAsync($body, $authorization = null, $allow_inline = 'true', $compress = 'false', $keytype = 'STRING', $max_concurrent_threads = '1', $max_retries = null, $predexp = 'null', $read_mode_ap = 'ONE', $read_mode_sc = 'SESSION', $record_bins = null, $replica = 'SEQUENCE', $send_key = 'false', $send_set_name = 'false', $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        return $this->performBatchGetAsyncWithHttpInfo($body, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performBatchGetAsyncWithHttpInfo
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \Swagger\Client\Model\BatchReadRequest[] $body batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#x27;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional, default to true)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional, default to false)
     * @param  string $keytype The Type of the userKey. (optional, default to STRING)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional, default to 1)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional, default to null)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional, default to ONE)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional, default to SESSION)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional, default to SEQUENCE)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional, default to false)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional, default to false)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performBatchGetAsyncWithHttpInfo($body, $authorization = null, $allow_inline = 'true', $compress = 'false', $keytype = 'STRING', $max_concurrent_threads = '1', $max_retries = null, $predexp = 'null', $read_mode_ap = 'ONE', $read_mode_sc = 'SESSION', $record_bins = null, $replica = 'SEQUENCE', $send_key = 'false', $send_set_name = 'false', $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $returnType = '\Swagger\Client\Model\BatchRead[]';
        $request = $this->performBatchGetRequest($body, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performBatchGet'
     *
     * @param  \Swagger\Client\Model\BatchReadRequest[] $body batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#x27;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional, default to true)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional, default to false)
     * @param  string $keytype The Type of the userKey. (optional, default to STRING)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional, default to 1)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional, default to null)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional, default to ONE)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional, default to SESSION)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional, default to SEQUENCE)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional, default to false)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional, default to false)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function performBatchGetRequest($body, $authorization = null, $allow_inline = 'true', $compress = 'false', $keytype = 'STRING', $max_concurrent_threads = '1', $max_retries = null, $predexp = 'null', $read_mode_ap = 'ONE', $read_mode_sc = 'SESSION', $record_bins = null, $replica = 'SEQUENCE', $send_key = 'false', $send_set_name = 'false', $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling performBatchGet'
            );
        }

        $resourcePath = '/v1/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($allow_inline !== null) {
            $queryParams['allowInline'] = ObjectSerializer::toQueryValue($allow_inline, null);
        }
        // query params
        if ($compress !== null) {
            $queryParams['compress'] = ObjectSerializer::toQueryValue($compress, null);
        }
        // query params
        if ($keytype !== null) {
            $queryParams['keytype'] = ObjectSerializer::toQueryValue($keytype, null);
        }
        // query params
        if ($max_concurrent_threads !== null) {
            $queryParams['maxConcurrentThreads'] = ObjectSerializer::toQueryValue($max_concurrent_threads, 'int32');
        }
        // query params
        if ($max_retries !== null) {
            $queryParams['maxRetries'] = ObjectSerializer::toQueryValue($max_retries, 'int32');
        }
        // query params
        if ($predexp !== null) {
            $queryParams['predexp'] = ObjectSerializer::toQueryValue($predexp, null);
        }
        // query params
        if ($read_mode_ap !== null) {
            $queryParams['readModeAP'] = ObjectSerializer::toQueryValue($read_mode_ap, null);
        }
        // query params
        if ($read_mode_sc !== null) {
            $queryParams['readModeSC'] = ObjectSerializer::toQueryValue($read_mode_sc, null);
        }
        // query params
        if (is_array($record_bins)) {
            $record_bins = ObjectSerializer::serializeCollection($record_bins, 'multi', true);
        }
        if ($record_bins !== null) {
            $queryParams['recordBins'] = ObjectSerializer::toQueryValue($record_bins, null);
        }
        // query params
        if ($replica !== null) {
            $queryParams['replica'] = ObjectSerializer::toQueryValue($replica, null);
        }
        // query params
        if ($send_key !== null) {
            $queryParams['sendKey'] = ObjectSerializer::toQueryValue($send_key, null);
        }
        // query params
        if ($send_set_name !== null) {
            $queryParams['sendSetName'] = ObjectSerializer::toQueryValue($send_set_name, null);
        }
        // query params
        if ($sleep_between_retries !== null) {
            $queryParams['sleepBetweenRetries'] = ObjectSerializer::toQueryValue($sleep_between_retries, 'int32');
        }
        // query params
        if ($socket_timeout !== null) {
            $queryParams['socketTimeout'] = ObjectSerializer::toQueryValue($socket_timeout, 'int32');
        }
        // query params
        if ($total_timeout !== null) {
            $queryParams['totalTimeout'] = ObjectSerializer::toQueryValue($total_timeout, 'int32');
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/msgpack']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/msgpack'],
                ['application/json', 'application/msgpack']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
