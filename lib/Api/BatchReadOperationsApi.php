<?php
/**
 * BatchReadOperationsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Aerospike REST Client
 *
 * REST Interface for Aerospike Database.
 *
 * The version of the OpenAPI document: 1.6.2
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta3
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * BatchReadOperationsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BatchReadOperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation performBatchGet
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \OpenAPI\Client\Model\BatchReadRequest[] $batch_keys batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#39;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BatchRead[]|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError
     */
    public function performBatchGet($batch_keys, $authorization = null, $allow_inline = null, $compress = null, $keytype = null, $max_concurrent_threads = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $replica = null, $send_key = null, $send_set_name = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        list($response) = $this->performBatchGetWithHttpInfo($batch_keys, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout);
        return $response;
    }

    /**
     * Operation performBatchGetWithHttpInfo
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \OpenAPI\Client\Model\BatchReadRequest[] $batch_keys batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#39;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BatchRead[]|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError, HTTP status code, HTTP response headers (array of strings)
     */
    public function performBatchGetWithHttpInfo($batch_keys, $authorization = null, $allow_inline = null, $compress = null, $keytype = null, $max_concurrent_threads = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $replica = null, $send_key = null, $send_set_name = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $request = $this->performBatchGetRequest($batch_keys, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BatchRead[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BatchRead[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BatchRead[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchRead[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation performBatchGetAsync
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \OpenAPI\Client\Model\BatchReadRequest[] $batch_keys batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#39;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performBatchGetAsync($batch_keys, $authorization = null, $allow_inline = null, $compress = null, $keytype = null, $max_concurrent_threads = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $replica = null, $send_key = null, $send_set_name = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        return $this->performBatchGetAsyncWithHttpInfo($batch_keys, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performBatchGetAsyncWithHttpInfo
     *
     * Return multiple records from the server in a single request.
     *
     * @param  \OpenAPI\Client\Model\BatchReadRequest[] $batch_keys batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#39;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performBatchGetAsyncWithHttpInfo($batch_keys, $authorization = null, $allow_inline = null, $compress = null, $keytype = null, $max_concurrent_threads = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $replica = null, $send_key = null, $send_set_name = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $returnType = '\OpenAPI\Client\Model\BatchRead[]';
        $request = $this->performBatchGetRequest($batch_keys, $authorization, $allow_inline, $compress, $keytype, $max_concurrent_threads, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $replica, $send_key, $send_set_name, $sleep_between_retries, $socket_timeout, $total_timeout);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performBatchGet'
     *
     * @param  \OpenAPI\Client\Model\BatchReadRequest[] $batch_keys batchKeys (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $allow_inline Allow batch to be processed immediately in the server&#39;s receiving thread when the server deems it to be appropriate.  If false, the batch will always be processed in separate transaction threads.  This field is only relevant for the new batch index protocol. (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_threads Maximum number of concurrent synchronous batch request threads to server nodes at any point in time. If there are 16 node/namespace combinations requested and maxConcurrentThreads is 8, then batch requests will be made for 8 node/namespace combinations in parallel threads. When a request completes, a new request will be issued until all 16 requests are complete. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  bool $send_set_name Send set name field to server for every key in the batch for batch index protocol. This is only necessary when authentication is enabled and security roles are defined on a per set basis. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function performBatchGetRequest($batch_keys, $authorization = null, $allow_inline = null, $compress = null, $keytype = null, $max_concurrent_threads = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $replica = null, $send_key = null, $send_set_name = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        // verify the required parameter 'batch_keys' is set
        if ($batch_keys === null || (is_array($batch_keys) && count($batch_keys) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_keys when calling performBatchGet'
            );
        }

        $resourcePath = '/v1/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($allow_inline)) {
            $allow_inline = ObjectSerializer::serializeCollection($allow_inline, '', true);
        }
        if ($allow_inline !== null) {
            $queryParams['allowInline'] = $allow_inline;
        }
        // query params
        if (is_array($compress)) {
            $compress = ObjectSerializer::serializeCollection($compress, '', true);
        }
        if ($compress !== null) {
            $queryParams['compress'] = $compress;
        }
        // query params
        if (is_array($keytype)) {
            $keytype = ObjectSerializer::serializeCollection($keytype, '', true);
        }
        if ($keytype !== null) {
            $queryParams['keytype'] = $keytype;
        }
        // query params
        if (is_array($max_concurrent_threads)) {
            $max_concurrent_threads = ObjectSerializer::serializeCollection($max_concurrent_threads, '', true);
        }
        if ($max_concurrent_threads !== null) {
            $queryParams['maxConcurrentThreads'] = $max_concurrent_threads;
        }
        // query params
        if (is_array($max_retries)) {
            $max_retries = ObjectSerializer::serializeCollection($max_retries, '', true);
        }
        if ($max_retries !== null) {
            $queryParams['maxRetries'] = $max_retries;
        }
        // query params
        if (is_array($predexp)) {
            $predexp = ObjectSerializer::serializeCollection($predexp, '', true);
        }
        if ($predexp !== null) {
            $queryParams['predexp'] = $predexp;
        }
        // query params
        if (is_array($read_mode_ap)) {
            $read_mode_ap = ObjectSerializer::serializeCollection($read_mode_ap, '', true);
        }
        if ($read_mode_ap !== null) {
            $queryParams['readModeAP'] = $read_mode_ap;
        }
        // query params
        if (is_array($read_mode_sc)) {
            $read_mode_sc = ObjectSerializer::serializeCollection($read_mode_sc, '', true);
        }
        if ($read_mode_sc !== null) {
            $queryParams['readModeSC'] = $read_mode_sc;
        }
        // query params
        if ($record_bins !== null) {
            if('form' === 'form' && is_array($record_bins)) {
                foreach($record_bins as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['recordBins'] = $record_bins;
            }
        }
        // query params
        if (is_array($replica)) {
            $replica = ObjectSerializer::serializeCollection($replica, '', true);
        }
        if ($replica !== null) {
            $queryParams['replica'] = $replica;
        }
        // query params
        if (is_array($send_key)) {
            $send_key = ObjectSerializer::serializeCollection($send_key, '', true);
        }
        if ($send_key !== null) {
            $queryParams['sendKey'] = $send_key;
        }
        // query params
        if (is_array($send_set_name)) {
            $send_set_name = ObjectSerializer::serializeCollection($send_set_name, '', true);
        }
        if ($send_set_name !== null) {
            $queryParams['sendSetName'] = $send_set_name;
        }
        // query params
        if (is_array($sleep_between_retries)) {
            $sleep_between_retries = ObjectSerializer::serializeCollection($sleep_between_retries, '', true);
        }
        if ($sleep_between_retries !== null) {
            $queryParams['sleepBetweenRetries'] = $sleep_between_retries;
        }
        // query params
        if (is_array($socket_timeout)) {
            $socket_timeout = ObjectSerializer::serializeCollection($socket_timeout, '', true);
        }
        if ($socket_timeout !== null) {
            $queryParams['socketTimeout'] = $socket_timeout;
        }
        // query params
        if (is_array($total_timeout)) {
            $total_timeout = ObjectSerializer::serializeCollection($total_timeout, '', true);
        }
        if ($total_timeout !== null) {
            $queryParams['totalTimeout'] = $total_timeout;
        }

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/msgpack']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/msgpack'],
                ['application/json', 'application/msgpack']
            );
        }

        // for model (json/xml)
        if (isset($batch_keys)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($batch_keys));
            } else {
                $httpBody = $batch_keys;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
