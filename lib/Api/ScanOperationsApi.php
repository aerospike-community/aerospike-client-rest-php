<?php
/**
 * ScanOperationsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Aerospike REST Client
 *
 * REST Interface for Aerospike Database.
 *
 * The version of the OpenAPI document: 1.6.2
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-beta3
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ScanOperationsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ScanOperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation performScan
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $set Set for the record; equivalent to database table. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RestClientScanResponse|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError
     */
    public function performScan($namespace, $set, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        list($response) = $this->performScanWithHttpInfo($namespace, $set, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout);
        return $response;
    }

    /**
     * Operation performScanWithHttpInfo
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $set Set for the record; equivalent to database table. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RestClientScanResponse|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError, HTTP status code, HTTP response headers (array of strings)
     */
    public function performScanWithHttpInfo($namespace, $set, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $request = $this->performScanRequest($namespace, $set, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RestClientScanResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientScanResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RestClientScanResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientScanResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation performScanAsync
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $set Set for the record; equivalent to database table. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performScanAsync($namespace, $set, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        return $this->performScanAsyncWithHttpInfo($namespace, $set, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performScanAsyncWithHttpInfo
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $set Set for the record; equivalent to database table. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performScanAsyncWithHttpInfo($namespace, $set, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $returnType = '\OpenAPI\Client\Model\RestClientScanResponse';
        $request = $this->performScanRequest($namespace, $set, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performScan'
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $set Set for the record; equivalent to database table. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function performScanRequest($namespace, $set, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null || (is_array($namespace) && count($namespace) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling performScan'
            );
        }
        // verify the required parameter 'set' is set
        if ($set === null || (is_array($set) && count($set) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $set when calling performScan'
            );
        }

        $resourcePath = '/v1/scan/{namespace}/{set}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($compress)) {
            $compress = ObjectSerializer::serializeCollection($compress, '', true);
        }
        if ($compress !== null) {
            $queryParams['compress'] = $compress;
        }
        // query params
        if (is_array($concurrent_nodes)) {
            $concurrent_nodes = ObjectSerializer::serializeCollection($concurrent_nodes, '', true);
        }
        if ($concurrent_nodes !== null) {
            $queryParams['concurrentNodes'] = $concurrent_nodes;
        }
        // query params
        if (is_array($fail_on_cluster_change)) {
            $fail_on_cluster_change = ObjectSerializer::serializeCollection($fail_on_cluster_change, '', true);
        }
        if ($fail_on_cluster_change !== null) {
            $queryParams['failOnClusterChange'] = $fail_on_cluster_change;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($include_bin_data)) {
            $include_bin_data = ObjectSerializer::serializeCollection($include_bin_data, '', true);
        }
        if ($include_bin_data !== null) {
            $queryParams['includeBinData'] = $include_bin_data;
        }
        // query params
        if (is_array($keytype)) {
            $keytype = ObjectSerializer::serializeCollection($keytype, '', true);
        }
        if ($keytype !== null) {
            $queryParams['keytype'] = $keytype;
        }
        // query params
        if (is_array($max_concurrent_nodes)) {
            $max_concurrent_nodes = ObjectSerializer::serializeCollection($max_concurrent_nodes, '', true);
        }
        if ($max_concurrent_nodes !== null) {
            $queryParams['maxConcurrentNodes'] = $max_concurrent_nodes;
        }
        // query params
        if (is_array($max_records)) {
            $max_records = ObjectSerializer::serializeCollection($max_records, '', true);
        }
        if ($max_records !== null) {
            $queryParams['maxRecords'] = $max_records;
        }
        // query params
        if (is_array($max_retries)) {
            $max_retries = ObjectSerializer::serializeCollection($max_retries, '', true);
        }
        if ($max_retries !== null) {
            $queryParams['maxRetries'] = $max_retries;
        }
        // query params
        if (is_array($predexp)) {
            $predexp = ObjectSerializer::serializeCollection($predexp, '', true);
        }
        if ($predexp !== null) {
            $queryParams['predexp'] = $predexp;
        }
        // query params
        if (is_array($read_mode_ap)) {
            $read_mode_ap = ObjectSerializer::serializeCollection($read_mode_ap, '', true);
        }
        if ($read_mode_ap !== null) {
            $queryParams['readModeAP'] = $read_mode_ap;
        }
        // query params
        if (is_array($read_mode_sc)) {
            $read_mode_sc = ObjectSerializer::serializeCollection($read_mode_sc, '', true);
        }
        if ($read_mode_sc !== null) {
            $queryParams['readModeSC'] = $read_mode_sc;
        }
        // query params
        if ($record_bins !== null) {
            if('form' === 'form' && is_array($record_bins)) {
                foreach($record_bins as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['recordBins'] = $record_bins;
            }
        }
        // query params
        if (is_array($records_per_second)) {
            $records_per_second = ObjectSerializer::serializeCollection($records_per_second, '', true);
        }
        if ($records_per_second !== null) {
            $queryParams['recordsPerSecond'] = $records_per_second;
        }
        // query params
        if (is_array($replica)) {
            $replica = ObjectSerializer::serializeCollection($replica, '', true);
        }
        if ($replica !== null) {
            $queryParams['replica'] = $replica;
        }
        // query params
        if (is_array($scan_percent)) {
            $scan_percent = ObjectSerializer::serializeCollection($scan_percent, '', true);
        }
        if ($scan_percent !== null) {
            $queryParams['scanPercent'] = $scan_percent;
        }
        // query params
        if (is_array($send_key)) {
            $send_key = ObjectSerializer::serializeCollection($send_key, '', true);
        }
        if ($send_key !== null) {
            $queryParams['sendKey'] = $send_key;
        }
        // query params
        if (is_array($sleep_between_retries)) {
            $sleep_between_retries = ObjectSerializer::serializeCollection($sleep_between_retries, '', true);
        }
        if ($sleep_between_retries !== null) {
            $queryParams['sleepBetweenRetries'] = $sleep_between_retries;
        }
        // query params
        if (is_array($socket_timeout)) {
            $socket_timeout = ObjectSerializer::serializeCollection($socket_timeout, '', true);
        }
        if ($socket_timeout !== null) {
            $queryParams['socketTimeout'] = $socket_timeout;
        }
        // query params
        if (is_array($total_timeout)) {
            $total_timeout = ObjectSerializer::serializeCollection($total_timeout, '', true);
        }
        if ($total_timeout !== null) {
            $queryParams['totalTimeout'] = $total_timeout;
        }

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }
        // path params
        if ($set !== null) {
            $resourcePath = str_replace(
                '{' . 'set' . '}',
                ObjectSerializer::toPathValue($set),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/msgpack']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/msgpack'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation performScan1
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RestClientScanResponse|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError
     */
    public function performScan1($namespace, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        list($response) = $this->performScan1WithHttpInfo($namespace, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout);
        return $response;
    }

    /**
     * Operation performScan1WithHttpInfo
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RestClientScanResponse|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError|\OpenAPI\Client\Model\RestClientError, HTTP status code, HTTP response headers (array of strings)
     */
    public function performScan1WithHttpInfo($namespace, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $request = $this->performScan1Request($namespace, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RestClientScanResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientScanResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\RestClientError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RestClientError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RestClientScanResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientScanResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestClientError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation performScan1Async
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performScan1Async($namespace, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        return $this->performScan1AsyncWithHttpInfo($namespace, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performScan1AsyncWithHttpInfo
     *
     * Return multiple records from the server in a scan request.
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performScan1AsyncWithHttpInfo($namespace, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        $returnType = '\OpenAPI\Client\Model\RestClientScanResponse';
        $request = $this->performScan1Request($namespace, $authorization, $compress, $concurrent_nodes, $fail_on_cluster_change, $from, $include_bin_data, $keytype, $max_concurrent_nodes, $max_records, $max_retries, $predexp, $read_mode_ap, $read_mode_sc, $record_bins, $records_per_second, $replica, $scan_percent, $send_key, $sleep_between_retries, $socket_timeout, $total_timeout);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performScan1'
     *
     * @param  string $namespace Namespace for the record; equivalent to database name. (required)
     * @param  string $authorization Authorization (optional)
     * @param  bool $compress Use zlib compression on command buffers sent to the server and responses received from the server when the buffer size is greater than 128 bytes. (optional)
     * @param  bool $concurrent_nodes Should scan requests be issued in parallel. (optional)
     * @param  bool $fail_on_cluster_change Terminate scan if cluster in migration state. Only used for server versions &lt; 4.9. (optional)
     * @param  string $from Next page token parameter. (optional)
     * @param  bool $include_bin_data Should bin data be retrieved. If false, only record digests (and user keys if stored on the server) are retrieved. (optional)
     * @param  string $keytype The Type of the userKey. (optional)
     * @param  int $max_concurrent_nodes Maximum number of concurrent requests to server nodes at any point in time. If there are 16 nodes in the cluster and maxConcurrentNodes is 8, then scan requests will be made to 8 nodes in parallel.  When a scan completes, a new scan request will be issued until all 16 nodes have been scanned. This field is only relevant when concurrentNodes is true. (optional)
     * @param  int $max_records Number of records to return. (optional)
     * @param  int $max_retries Maximum number of retries before aborting the current transaction. The initial attempt is not counted as a retry. (optional)
     * @param  string $predexp Optional predicate expression filter in postfix notation. If the predicate expression exists and evaluates to false, the transaction is ignored. (optional)
     * @param  string $read_mode_ap Read policy for AP (availability) namespaces. How duplicates should be consulted in a read operation. Only makes a difference during migrations and only applicable in AP mode. (optional)
     * @param  string $read_mode_sc Read policy for SC (strong consistency) namespaces. Determines SC read consistency options. (optional)
     * @param  string[] $record_bins Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned. (optional)
     * @param  int $records_per_second Limit returned records per second (rps) rate for each server. Do not apply rps limit if recordsPerSecond is zero. (optional)
     * @param  string $replica Replica algorithm used to determine the target node for a single record command. (optional)
     * @param  int $scan_percent Percent of data to scan. Valid integer range is 1 to 100. This field is supported on server versions &lt; 4.9. For server versions &gt;&#x3D; 4.9, use maxRecords. (optional)
     * @param  bool $send_key Send user defined key in addition to hash digest on both reads and writes. (optional)
     * @param  int $sleep_between_retries Milliseconds to sleep between retries. (optional)
     * @param  int $socket_timeout Socket idle timeout in milliseconds when processing a database command. (optional)
     * @param  int $total_timeout Total transaction timeout in milliseconds. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function performScan1Request($namespace, $authorization = null, $compress = null, $concurrent_nodes = null, $fail_on_cluster_change = null, $from = null, $include_bin_data = null, $keytype = null, $max_concurrent_nodes = null, $max_records = null, $max_retries = null, $predexp = null, $read_mode_ap = null, $read_mode_sc = null, $record_bins = null, $records_per_second = null, $replica = null, $scan_percent = null, $send_key = null, $sleep_between_retries = null, $socket_timeout = null, $total_timeout = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null || (is_array($namespace) && count($namespace) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling performScan1'
            );
        }

        $resourcePath = '/v1/scan/{namespace}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($compress)) {
            $compress = ObjectSerializer::serializeCollection($compress, '', true);
        }
        if ($compress !== null) {
            $queryParams['compress'] = $compress;
        }
        // query params
        if (is_array($concurrent_nodes)) {
            $concurrent_nodes = ObjectSerializer::serializeCollection($concurrent_nodes, '', true);
        }
        if ($concurrent_nodes !== null) {
            $queryParams['concurrentNodes'] = $concurrent_nodes;
        }
        // query params
        if (is_array($fail_on_cluster_change)) {
            $fail_on_cluster_change = ObjectSerializer::serializeCollection($fail_on_cluster_change, '', true);
        }
        if ($fail_on_cluster_change !== null) {
            $queryParams['failOnClusterChange'] = $fail_on_cluster_change;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($include_bin_data)) {
            $include_bin_data = ObjectSerializer::serializeCollection($include_bin_data, '', true);
        }
        if ($include_bin_data !== null) {
            $queryParams['includeBinData'] = $include_bin_data;
        }
        // query params
        if (is_array($keytype)) {
            $keytype = ObjectSerializer::serializeCollection($keytype, '', true);
        }
        if ($keytype !== null) {
            $queryParams['keytype'] = $keytype;
        }
        // query params
        if (is_array($max_concurrent_nodes)) {
            $max_concurrent_nodes = ObjectSerializer::serializeCollection($max_concurrent_nodes, '', true);
        }
        if ($max_concurrent_nodes !== null) {
            $queryParams['maxConcurrentNodes'] = $max_concurrent_nodes;
        }
        // query params
        if (is_array($max_records)) {
            $max_records = ObjectSerializer::serializeCollection($max_records, '', true);
        }
        if ($max_records !== null) {
            $queryParams['maxRecords'] = $max_records;
        }
        // query params
        if (is_array($max_retries)) {
            $max_retries = ObjectSerializer::serializeCollection($max_retries, '', true);
        }
        if ($max_retries !== null) {
            $queryParams['maxRetries'] = $max_retries;
        }
        // query params
        if (is_array($predexp)) {
            $predexp = ObjectSerializer::serializeCollection($predexp, '', true);
        }
        if ($predexp !== null) {
            $queryParams['predexp'] = $predexp;
        }
        // query params
        if (is_array($read_mode_ap)) {
            $read_mode_ap = ObjectSerializer::serializeCollection($read_mode_ap, '', true);
        }
        if ($read_mode_ap !== null) {
            $queryParams['readModeAP'] = $read_mode_ap;
        }
        // query params
        if (is_array($read_mode_sc)) {
            $read_mode_sc = ObjectSerializer::serializeCollection($read_mode_sc, '', true);
        }
        if ($read_mode_sc !== null) {
            $queryParams['readModeSC'] = $read_mode_sc;
        }
        // query params
        if ($record_bins !== null) {
            if('form' === 'form' && is_array($record_bins)) {
                foreach($record_bins as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['recordBins'] = $record_bins;
            }
        }
        // query params
        if (is_array($records_per_second)) {
            $records_per_second = ObjectSerializer::serializeCollection($records_per_second, '', true);
        }
        if ($records_per_second !== null) {
            $queryParams['recordsPerSecond'] = $records_per_second;
        }
        // query params
        if (is_array($replica)) {
            $replica = ObjectSerializer::serializeCollection($replica, '', true);
        }
        if ($replica !== null) {
            $queryParams['replica'] = $replica;
        }
        // query params
        if (is_array($scan_percent)) {
            $scan_percent = ObjectSerializer::serializeCollection($scan_percent, '', true);
        }
        if ($scan_percent !== null) {
            $queryParams['scanPercent'] = $scan_percent;
        }
        // query params
        if (is_array($send_key)) {
            $send_key = ObjectSerializer::serializeCollection($send_key, '', true);
        }
        if ($send_key !== null) {
            $queryParams['sendKey'] = $send_key;
        }
        // query params
        if (is_array($sleep_between_retries)) {
            $sleep_between_retries = ObjectSerializer::serializeCollection($sleep_between_retries, '', true);
        }
        if ($sleep_between_retries !== null) {
            $queryParams['sleepBetweenRetries'] = $sleep_between_retries;
        }
        // query params
        if (is_array($socket_timeout)) {
            $socket_timeout = ObjectSerializer::serializeCollection($socket_timeout, '', true);
        }
        if ($socket_timeout !== null) {
            $queryParams['socketTimeout'] = $socket_timeout;
        }
        // query params
        if (is_array($total_timeout)) {
            $total_timeout = ObjectSerializer::serializeCollection($total_timeout, '', true);
        }
        if ($total_timeout !== null) {
            $queryParams['totalTimeout'] = $total_timeout;
        }

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/msgpack']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/msgpack'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
